runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev/markdown")
library(knitr)
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/markdown")
knit("details.Rmd")
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev/markdown")
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev/markdown")
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/noheatmap')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev/markdown")
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny/dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev")
load("initial_params.RData")
params
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny')
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev")
# incubation from Lauer et al
log_incubation_sd<-qnorm(0.975)-sqrt(qnorm(0.975)^2-2*(log(10.5)-log(5.5)))
log_incubation_median<-log(10.5)-log_incubation_sd*qnorm(0.975)
#S<-function(x){1-plnorm(x,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
# Michelle exponential approximation
#S<-function(x){exp(-x/5.2)}
# my Weibull generation time
beta<-function(x){
dweibull(x, shape = 2.826027, scale = 5.665302)
}
fa<-0.055
fe<-0.1
delays<-c(0,4,12,24,48,72) # in hours
listR0<-c(1.7,2,2.5)
Yerror<-0.001
miniter<-3
maxiter<-100
nmax<-240
ndiscr<-10 # discretization of the unit for integral
n<-25 #discretization parameters
# generate matrices
r_matrix<-list()
n<-5 #discretization parameters
# generate matrices
r_matrix<-list()
for(delay in delays){
for(R0 in listR0){
print(c(R0,delay))
S<-function(x){1-(1-fa)*plnorm(x-delay/24,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
# auxiliary functions
M1<-function(x){R0*beta(x)*(1-ei+ei*S(x))}
M2<-function(x,y){(1-et+et*S(x+y)/S(y))}
# discretization of the integral
v<-c(1:nmax)/ndiscr
# initialization
Y<-rep(1,nmax)/nmax
r<-0
m<-matrix(0,nrow=n-1,ncol=n-1)
for(ci in 1:(n-1)){
for(cj in 1:(n-1)){
ei<-ci/n ; et<-cj/n*(1-fe)
eigen<-function(my_r){
r<-my_r
Y<-rep(1,nmax)/nmax;
Yold<-Y
for(i in 1:maxiter){
Y<-M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})
Y<-Y/sum(Y)
if(sum(abs(Y-Yold))<Yerror & i>=miniter){break}
Yold<-Y
}
return(lm(I(M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})) ~ Y)$coeff[2]-1)
}
m[ci,cj]<-tryCatch(uniroot(eigen,interval = c(-2,2))$root, error = function(e) {return(NA)} ) }
}
colnames(m)<-c(1:(n-1))/n
rownames(m)<-c(1:(n-1))/n
r_matrix[[paste(as.character(R0),as.character(delay),sep="_")]]<-m
}
}
r_matrix
# include also environmental fraction
fe<-0.1
fa<-0.055
S<-function(x){1-(1-fa)*plnorm(x,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
M1<-function(x){beta(x)*(1-ei+ei*S(x))}
M2<-function(x,y){(1-et+et*S(x+y)/S(y))}
nmax<-200
ndiscr<-10
v<-c(1:nmax)/ndiscr
Y<-rep(1,nmax)/nmax
n<-10
m<-matrix(0,nrow=n-1,ncol=n-1)
for(ci in 1:(n-1)){
for(cj in 1:(n-1)){
ei<-ci/n ; et<-cj/n*(1-fe)
Y<-rep(1,nmax)/nmax;
for(i in 1:10){ # change this for convergence...
Y<-M1(v)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})
Y<-Y/sum(Y)
}
m[ci,cj]<-(lm(I(M1(v)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})) ~ Y)$coeff[2])
}
}
colnames(m)<-c(1:(n-1))/n
rownames(m)<-c(1:(n-1))/n
m<-1/m
df <- tibble(x=numeric((n-1)^2), y=numeric((n-1)^2), z=numeric((n-1)^2))
count <- 0
for (i in 1:(n-1)) {
for (j in 1:(n-1)) {
count <- count + 1
df[count,] <- list(x = rownames(m)[[i]],
x = colnames(m)[[j]],
z = m[i,j])
}
}
df$x <- 100 * as.numeric(df$x)
df$y <- 100 * as.numeric(df$y)
library(ggplot2)
library(viridis)
p_d <- ggplot(df, aes(x, y, fill = z)) +
theme_bw(base_size = 16) +
coord_cartesian(expand = F) +
geom_tile() +
scale_fill_viridis(limits=c(1,4.5)) +
labs(subtitle = paste0("proportion of transmission from asymptomatic individuals = ", 100 * fa,
"%,\nproportion of transmission from the environment = ", 100 * fe, "%"),
x = "% success in isolating cases",
y = "% success in quarantining contacts",
fill = expression("R"[0])) + # * "that can be contained"))
stat_contour(aes(z=z), breaks=2, color = "red", size = 1) +
stat_contour(aes(z=z), breaks=1.7, color = "red", linetype = 2, size = 1) +
stat_contour(aes(z=z), breaks=2.5, color = "red", linetype = 2, size = 1) +
scale_x_continuous(breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)) +
scale_y_continuous(breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100))
p_d
# incubation from Lauer et al
log_incubation_sd<-qnorm(0.975)-sqrt(qnorm(0.975)^2-2*(log(10.5)-log(5.5)))
log_incubation_median<-log(10.5)-log_incubation_sd*qnorm(0.975)
#S<-function(x){1-plnorm(x,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
# Michelle exponential approximation
#S<-function(x){exp(-x/5.2)}
# my Weibull generation time
beta<-function(x){
dweibull(x, shape = 2.826027, scale = 5.665302)
}
# generate matrices
r_matrix<-list()
delay <- 0
S<-function(x){1-plnorm(x-delay/24,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
R0 <- 2
# auxiliary functions
M1<-function(x){R0*beta(x)*(1-ei+ei*S(x))}
M2<-function(x,y){(1-et+et*S(x+y)/S(y))}
# discretization of the integral
nmax<-240
ndiscr<-10
v<-c(1:nmax)/ndiscr
# initialization
Y<-rep(1,nmax)/nmax
r<-0
n <- 10
m<-matrix(0,nrow=n-1,ncol=n-1)
for(ci in 1:(n-1)){
for(cj in 1:(n-1)){
ei<-ci/n ; et<-cj/n
Y<-rep(1,nmax)/nmax;
eigen<-function(my_r){
r<-my_r
for(i in 1:10){ # change this for convergence...
Y<-M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})
Y<-Y/sum(Y)
}
return(lm(I(M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})) ~ Y)$coeff[2]-1)
}
m[ci,cj]<-tryCatch(uniroot(eigen,interval = c(-2,2))$root, error = function(e) {return(NA)} ) }
}
runApp()
runApp()
r_matrix
# incubation from Lauer et al
log_incubation_sd<-qnorm(0.975)-sqrt(qnorm(0.975)^2-2*(log(10.5)-log(5.5)))
log_incubation_median<-log(10.5)-log_incubation_sd*qnorm(0.975)
#S<-function(x){1-plnorm(x,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
# Michelle exponential approximation
#S<-function(x){exp(-x/5.2)}
# my Weibull generation time
beta<-function(x){
dweibull(x, shape = 2.826027, scale = 5.665302)
}
fa<-0.055
fe<-0.1
delays <- 0
R0 <- 2
Yerror<-0.001
miniter<-3
maxiter<-100
nmax<-240
ndiscr<-10 # discretization of the unit for integral
n <- 5
# generate matrices
r_matrix<-list()
print(c(R0,delay))
S<-function(x){1-(1-fa)*plnorm(x-delay/24,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
# auxiliary functions
M1<-function(x){R0*beta(x)*(1-ei+ei*S(x))}
M2<-function(x,y){(1-et+et*S(x+y)/S(y))}
# discretization of the integral
v<-c(1:nmax)/ndiscr
# initialization
Y<-rep(1,nmax)/nmax
r<-0
m<-matrix(0,nrow=n-1,ncol=n-1)
for(ci in 1:(n-1)){
for(cj in 1:(n-1)){
ei<-ci/n ; et<-cj/n*(1-fe)
eigen<-function(my_r){
r<-my_r
Y<-rep(1,nmax)/nmax;
Yold<-Y
for(i in 1:maxiter){
Y<-M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})
Y<-Y/sum(Y)
if(sum(abs(Y-Yold))<Yerror & i>=miniter){break}
Yold<-Y
}
return(lm(I(M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})) ~ Y)$coeff[2]-1)
}
m[ci,cj]<-tryCatch(uniroot(eigen,interval = c(-2,2))$root, error = function(e) {return(NA)} ) }
}
m
stopifnot(nrow(m) == ncol(m))
n <- nrow(m)
# Go from matrix shape to long format, where one column is the matrix row label
# and another is the matrix col label
df <- tibble(x=numeric((n-1)^2), y=numeric((n-1)^2), z=numeric((n-1)^2))
count <- 0
for (i in 1:(n-1)) {
for (j in 1:(n-1)) {
count <- count + 1
df[count,] <- list(x = rownames(m)[[i]],
x = colnames(m)[[j]],
z = m[i,j])
}
}
i <- 1
j <- 1
# Go from matrix shape to long format, where one column is the matrix row label
# and another is the matrix col label
df <- tibble(x=numeric((n-1)^2), y=numeric((n-1)^2), z=numeric((n-1)^2))
count <- 0
count
count <- count + 1
count
df[count,] <- list(x = rownames(m)[[i]],
x = colnames(m)[[j]],
z = m[i,j])
m[i,j]
rownames(m)
colnames(m)<-c(1:(n-1))/n
colnames(m)<-c(1:(n-1))/n
c(1:(n-1))/n
m
n <- 5
c(1:(n-1))/n
colnames(m)<-c(1:(n-1))/n
rownames(m)<-c(1:(n-1))/n
n <- nrow(m)
# Go from matrix shape to long format, where one column is the matrix row label
# and another is the matrix col label
df <- tibble(x=numeric((n-1)^2), y=numeric((n-1)^2), z=numeric((n-1)^2))
count <- 0
count <- count + 1
df[count,] <- list(x = rownames(m)[[i]],
x = colnames(m)[[j]],
z = m[i,j])
df
# Go from matrix shape to long format, where one column is the matrix row label
# and another is the matrix col label
df <- tibble(x=numeric((n-1)^2), y=numeric((n-1)^2), z=numeric((n-1)^2))
count <- 0
for (i in 1:(n-1)) {
for (j in 1:(n-1)) {
count <- count + 1
df[count,] <- list(x = rownames(m)[[i]],
x = colnames(m)[[j]],
z = m[i,j])
}
}
df
# remove the "X" at the start of the y values, and convert to percentages
df$y <- vapply(df$y, function(value) substring(value, 2), character(1))
df
df$x <- 100 * as.numeric(df$x)
df
df$y <- 100 * as.numeric(df$y)
df
zmin <- -0.3  # just less than min(df.cen$z) for delay = 0
zmax <- 0.14  # just more than max(df.cen$z) for delay = 72
df.cen <- df
ggplot() +
theme_bw(base_size = 16) +
coord_cartesian(expand = F) +
#scale_fill_viridis(limits=c(-0.4,0.2)) +
scale_fill_gradient2(limits = c(zmin, zmax),
low = color.r.neg, mid = "white", high = color.r.pos, midpoint = 0) +
labs(x = "% success in isolating cases",
y = "% success in quarantining contacts",
fill = "r (per day)",
title = paste0("delay = ", delay, " hours")) +
theme(plot.title = element_text(hjust = 0.5)) +
geom_tile(data = df.cen, aes(x, y, fill = z)) +
stat_contour(data = df.cen, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1) +
stat_contour(data = df.low, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1, linetype = "dashed") +
stat_contour(data = df.upp, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1, linetype = "dashed")
color.r.pos <- "#FC8D62" #"firebrick1"
color.r.neg <- "#66C2A5" #"royalblue"
ggplot() +
theme_bw(base_size = 16) +
coord_cartesian(expand = F) +
#scale_fill_viridis(limits=c(-0.4,0.2)) +
scale_fill_gradient2(limits = c(zmin, zmax),
low = color.r.neg, mid = "white", high = color.r.pos, midpoint = 0) +
labs(x = "% success in isolating cases",
y = "% success in quarantining contacts",
fill = "r (per day)",
title = paste0("delay = ", delay, " hours")) +
theme(plot.title = element_text(hjust = 0.5)) +
geom_tile(data = df.cen, aes(x, y, fill = z)) +
stat_contour(data = df.cen, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1) +
stat_contour(data = df.low, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1, linetype = "dashed") +
stat_contour(data = df.upp, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1, linetype = "dashed")
ggplot() +
theme_bw(base_size = 16) +
coord_cartesian(expand = F) +
#scale_fill_viridis(limits=c(-0.4,0.2)) +
scale_fill_gradient2(limits = c(zmin, zmax),
low = color.r.neg, mid = "white", high = color.r.pos, midpoint = 0) +
labs(x = "% success in isolating cases",
y = "% success in quarantining contacts",
fill = "r (per day)",
title = paste0("delay = ", delay, " hours")) +
theme(plot.title = element_text(hjust = 0.5)) +
geom_tile(data = df.cen, aes(x, y, fill = z)) +
stat_contour(data = df.cen, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1)
n<-25 #discretization parameters
S<-function(x){1-(1-fa)*plnorm(x-delay/24,meanlog = log_incubation_median, sdlog = log_incubation_sd)}
# auxiliary functions
M1<-function(x){R0*beta(x)*(1-ei+ei*S(x))}
M2<-function(x,y){(1-et+et*S(x+y)/S(y))}
# discretization of the integral
v<-c(1:nmax)/ndiscr
# initialization
Y<-rep(1,nmax)/nmax
r<-0
m<-matrix(0,nrow=n-1,ncol=n-1)
for(ci in 1:(n-1)){
for(cj in 1:(n-1)){
ei<-ci/n ; et<-cj/n*(1-fe)
eigen<-function(my_r){
r<-my_r
Y<-rep(1,nmax)/nmax;
Yold<-Y
for(i in 1:maxiter){
Y<-M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})
Y<-Y/sum(Y)
if(sum(abs(Y-Yold))<Yerror & i>=miniter){break}
Yold<-Y
}
return(lm(I(M1(v)*exp(-v*r)*sapply(v,function(z){sum(M2(z,v)*Y)/ndiscr})) ~ Y)$coeff[2]-1)
}
m[ci,cj]<-tryCatch(uniroot(eigen,interval = c(-2,2))$root, error = function(e) {return(NA)} ) }
}
colnames(m)<-c(1:(n-1))/n
rownames(m)<-c(1:(n-1))/n
# Go from matrix shape to long format, where one column is the matrix row label
# and another is the matrix col label
df <- tibble(x=numeric((n-1)^2), y=numeric((n-1)^2), z=numeric((n-1)^2))
count <- 0
for (i in 1:(n-1)) {
for (j in 1:(n-1)) {
count <- count + 1
df[count,] <- list(x = rownames(m)[[i]],
x = colnames(m)[[j]],
z = m[i,j])
}
}
# remove the "X" at the start of the y values, and convert to percentages
df$y <- vapply(df$y, function(value) substring(value, 2), character(1))
df$x <- 100 * as.numeric(df$x)
df$y <- 100 * as.numeric(df$y)
df
df.cen <- df
zmin <- -0.3  # just less than min(df.cen$z) for delay = 0
zmax <- 0.14  # just more than max(df.cen$z) for delay = 72
ggplot() +
theme_bw(base_size = 16) +
coord_cartesian(expand = F) +
#scale_fill_viridis(limits=c(-0.4,0.2)) +
scale_fill_gradient2(limits = c(zmin, zmax),
low = color.r.neg, mid = "white", high = color.r.pos, midpoint = 0) +
labs(x = "% success in isolating cases",
y = "% success in quarantining contacts",
fill = "r (per day)",
title = paste0("delay = ", delay, " hours")) +
theme(plot.title = element_text(hjust = 0.5)) +
geom_tile(data = df.cen, aes(x, y, fill = z)) +
stat_contour(data = df.cen, aes(x=x, y=y, z=z), breaks=0, color = "black", size = 1)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
exp(1.644)
exp(1.798)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages(c("audio", "Cairo", "covr", "dplyr", "foreign", "fs", "ggplot2", "ggrepel", "lifecycle", "nlme", "nloptr", "plyr", "scatterD3", "shinyWidgets", "survival", "testthat", "usedist", "vctrs", "xml2"))
shiny::runApp()
runApp()
runApp()
setwd("~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev/markdown")
knit("details.md")
library(knitr)
knit("details.md")
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
library(knitr)
knit("details.Rmd")
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
log(2)/5
log(2)/10
runApp('~/Dropbox (Infectious Disease)/Coronovirus_2020/shiny_dev')
knit("details.Rmd")
